var searchIndex = {};
searchIndex["anion"] = {"doc":"Rust implementation of Amazon&#39;s Ion data format","items":[[4,"AnionValue","anion","",null,null],[13,"Boolean","","",0,null],[13,"Integer","","",0,null],[13,"Float","","",0,null],[13,"String","","",0,null],[0,"parser","","Parsing code for Anion project",null,null],[3,"Rdp","anion::parser","",null,null],[4,"Rule","","",null,null],[13,"any","","",1,null],[13,"eoi","","",1,null],[13,"bin_int","","",1,null],[13,"oct_int","","",1,null],[13,"hex_int","","",1,null],[13,"int","","",1,null],[13,"null_int","","",1,null],[13,"float","","",1,null],[13,"null_float","","",1,null],[13,"boolean","","",1,null],[13,"string","","",1,null],[13,"escape","","",1,null],[13,"unicode_8d_esc","","",1,null],[13,"unicode_4d_esc","","",1,null],[13,"unicode_2d_esc","","",1,null],[13,"nz_digit","","",1,null],[13,"digits","","",1,null],[13,"hex_digit","","",1,null],[13,"oct_digit","","",1,null],[13,"bin_digit","","",1,null],[13,"digit","","",1,null],[13,"plus_or_minus","","",1,null],[5,"parse_string","","",null,{"inputs":[{"name":"str"}],"output":{"name":"option"}}],[11,"partial_cmp","","",1,null],[11,"eq","","",1,null],[11,"cmp","","",1,null],[11,"hash","","",1,null],[11,"fmt","","",1,null],[11,"clone","","",1,null],[11,"new","","",2,{"inputs":[{"name":"t"}],"output":{"name":"rdp"}}],[11,"comment","","",2,null],[11,"any","","",2,null],[11,"eoi","","",2,null],[11,"whitespace","","",2,null],[11,"plus_or_minus","","",2,null],[11,"digit","","",2,null],[11,"bin_digit","","",2,null],[11,"oct_digit","","",2,null],[11,"hex_digit","","",2,null],[11,"digits","","",2,null],[11,"nz_digit","","",2,null],[11,"unicode_2d_esc","","",2,null],[11,"unicode_4d_esc","","",2,null],[11,"unicode_8d_esc","","",2,null],[11,"escape","","",2,null],[11,"string","","",2,null],[11,"boolean","","",2,null],[11,"null_float","","",2,null],[11,"float","","",2,null],[11,"null_int","","",2,null],[11,"int","","",2,null],[11,"hex_int","","",2,null],[11,"oct_int","","",2,null],[11,"bin_int","","",2,null],[11,"try","","",2,null],[11,"prec_climb","","",2,null],[11,"string_value","","",2,null],[11,"int_value","","",2,null],[11,"float_value","","",2,null],[11,"boolean_value","","",2,null],[11,"input","","",2,null],[11,"input_mut","","",2,null],[11,"end","","",2,null],[11,"eoi_matched","","",2,null],[11,"reset","","",2,null],[11,"queue","","",2,null],[11,"queue_index","","",2,null],[11,"inc_queue_index","","",2,null],[11,"set_queue_index","","",2,null],[11,"queue_mut","","",2,null],[11,"skip_ws","","",2,null],[11,"skip_com","","",2,null],[11,"is_atomic","","",2,null],[11,"set_atomic","","",2,null],[11,"track","","",2,null],[11,"tracked_len","","",2,null],[11,"expected","","",2,null],[11,"clone","anion","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"fmt","","",0,null]],"paths":[[4,"AnionValue"],[4,"Rule"],[3,"Rdp"]]};
searchIndex["pest"] = {"doc":"# pest. Elegant, efficient grammars","items":[[3,"StringInput","pest","A `struct` useful for matching in-memory `String`s.",null,null],[3,"Token","","A `struct` representing tokens generated by a parser.",null,null],[12,"rule","","matched [`Rule`](macro.impl_rdp!#rule)",0,null],[12,"start","","starting position in `Input`",0,null],[12,"end","","ending position in `Input`",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"hash","","",0,null],[11,"fmt","","",0,null],[11,"clone","","",0,null],[11,"new","","Creates a new `Token`.",0,{"inputs":[{"name":"rule"},{"name":"usize"},{"name":"usize"}],"output":{"name":"token"}}],[11,"new","","Creates a new `StringInput` from a `&amp;str`.",1,{"inputs":[{"name":"str"}],"output":{"name":"stringinput"}}],[11,"len","","",1,null],[11,"is_empty","","",1,null],[11,"pos","","",1,null],[11,"set_pos","","",1,null],[11,"slice","","",1,null],[11,"line_col","","",1,null],[11,"match_string","","",1,null],[11,"match_range","","",1,null],[0,"prelude","","A `mod` that contains `pest::Input`, `pest::Parser`, `pest::StringInput`, and `pest::Token`.",null,null],[3,"StringInput","pest::prelude","A `struct` useful for matching in-memory `String`s.",null,null],[3,"Token","","A `struct` representing tokens generated by a parser.",null,null],[12,"rule","","matched [`Rule`](macro.impl_rdp!#rule)",0,null],[12,"start","","starting position in `Input`",0,null],[12,"end","","ending position in `Input`",0,null],[8,"Input","","A `trait` that defines an input for a `Parser`.",null,null],[10,"len","","Returns length of an `Input`.",2,null],[10,"is_empty","","Returns whether an `Input` is empty.",2,null],[10,"pos","","Returns current position of an `Input`.",2,null],[10,"set_pos","","Set current position of an `Input`.",2,null],[10,"slice","","Slices an `Input`.",2,null],[10,"line_col","","Returns the line and column of a position for an `Input`.",2,null],[10,"match_string","","Matches `string` to an `Input`, returns whether it matched, and advances the position with\n`string.len()` in case it did.",2,null],[10,"match_range","","Matches if an `Input`&#39;s current `char` is between `left` and `right`, and advances the\nposition with one `char` in case it did.",2,null],[8,"Parser","","A `trait` that defines a parser.",null,null],[16,"Rule","","",3,null],[16,"Token","","",3,null],[10,"input","","",3,null],[10,"input_mut","","",3,null],[10,"end","","Returns whether a `Parser` has reached its end.",3,null],[10,"eoi_matched","","Returns whether a `Parser` has matched end-of-input.",3,null],[10,"reset","","Reset a `Parser`.",3,null],[10,"queue","","Returns the queue of all matched `Token`s.",3,null],[10,"queue_mut","","Returns the mutable queue of all matched `Token`s.",3,null],[10,"queue_index","","Returns the current index within the queue. Used in `process!`.",3,null],[10,"inc_queue_index","","Increments the current index within the queue. Used in `process!`.",3,null],[10,"set_queue_index","","Set the current index within the queue. Used in `process!`.",3,null],[10,"skip_ws","","Skips white-space.",3,null],[10,"skip_com","","Skips comments.",3,null],[10,"is_atomic","","Returns whether a `Parser` is currently inside an atomic rule.",3,null],[10,"set_atomic","","Sets a `Parser` to atomic rule mode, barring comment &amp; white-space skipping.",3,null],[10,"track","","Keeps track of rule failures. It gets called when a `Rule` fails at `pos`.",3,null],[10,"tracked_len","","Returns the length of the tracked `Rule`s.",3,null],[10,"expected","","Retuns a `Vec` of all expected `Rule`s at the deepest position where the parsing last\nstopped. It only returns leafs from the rule tree. Used for error reporting.",3,null],[8,"Input","pest","A `trait` that defines an input for a `Parser`.",null,null],[10,"len","","Returns length of an `Input`.",2,null],[10,"is_empty","","Returns whether an `Input` is empty.",2,null],[10,"pos","","Returns current position of an `Input`.",2,null],[10,"set_pos","","Set current position of an `Input`.",2,null],[10,"slice","","Slices an `Input`.",2,null],[10,"line_col","","Returns the line and column of a position for an `Input`.",2,null],[10,"match_string","","Matches `string` to an `Input`, returns whether it matched, and advances the position with\n`string.len()` in case it did.",2,null],[10,"match_range","","Matches if an `Input`&#39;s current `char` is between `left` and `right`, and advances the\nposition with one `char` in case it did.",2,null],[8,"Parser","","A `trait` that defines a parser.",null,null],[16,"Rule","","",3,null],[16,"Token","","",3,null],[10,"input","","",3,null],[10,"input_mut","","",3,null],[10,"end","","Returns whether a `Parser` has reached its end.",3,null],[10,"eoi_matched","","Returns whether a `Parser` has matched end-of-input.",3,null],[10,"reset","","Reset a `Parser`.",3,null],[10,"queue","","Returns the queue of all matched `Token`s.",3,null],[10,"queue_mut","","Returns the mutable queue of all matched `Token`s.",3,null],[10,"queue_index","","Returns the current index within the queue. Used in `process!`.",3,null],[10,"inc_queue_index","","Increments the current index within the queue. Used in `process!`.",3,null],[10,"set_queue_index","","Set the current index within the queue. Used in `process!`.",3,null],[10,"skip_ws","","Skips white-space.",3,null],[10,"skip_com","","Skips comments.",3,null],[10,"is_atomic","","Returns whether a `Parser` is currently inside an atomic rule.",3,null],[10,"set_atomic","","Sets a `Parser` to atomic rule mode, barring comment &amp; white-space skipping.",3,null],[10,"track","","Keeps track of rule failures. It gets called when a `Rule` fails at `pos`.",3,null],[10,"tracked_len","","Returns the length of the tracked `Rule`s.",3,null],[10,"expected","","Retuns a `Vec` of all expected `Rule`s at the deepest position where the parsing last\nstopped. It only returns leafs from the rule tree. Used for error reporting.",3,null],[14,"grammar!","","A `macro` that defines each rule as a method on a `Parser` which parses from the current\nposition. Rules are always defined between braces, with an optional symbol marking the type of\nrule defined.",null,null],[14,"process!","","A `macro` for pattern-matching queued `Token`s generated by a `Parser`. It generates a method\n`process` on `&amp;self` that processes the whole queue of `Token`s, reducing it to one single\nresult.",null,null],[14,"impl_rdp!","","A `macro` useful for implementing the `Parser` `trait` as a recursive descent parser. It only\naccepts `grammar!` and `process!` calls that get implemented on `self`.",null,null]],"paths":[[3,"Token"],[3,"StringInput"],[8,"Input"],[8,"Parser"]]};
initSearch(searchIndex);
